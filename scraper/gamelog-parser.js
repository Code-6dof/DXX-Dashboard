/**
 * DXX-Redux Gamelog Parser
 * 
 * Parses gamelog.txt files generated by DXX-Redux (Descent 1/2) into
 * structured game event data. DXX-Redux writes all HUD messages to
 * gamelog.txt with timestamps (HH:MM:SS format) via con_printf(CON_HUD).
 * 
 * Events captured:
 *  - Kills (player vs player, with weapon info from kill messages)
 *  - Deaths (by reactor, robot, mine, lava, suicide)
 *  - Player joins / rejoins / disconnects
 *  - Control center / reactor destroyed
 *  - Player escapes
 *  - Chat messages
 *  - Kill goal reached
 *  - Shield warnings
 *  - Damage events (from observer damage lines)
 * 
 * Usage:
 *   const parser = require('./gamelog-parser');
 *   const events = parser.parseGamelog('/path/to/gamelog.txt');
 *   const summary = parser.summarize(events);
 * 
 * DXX-Redux flags:
 *   -gamelog_timestamp   Creates timestamped log files (gamelog-YYYYMMDD-HHMMSS.txt)
 *   -gamelog_split       Creates per-level log files
 */

const fs = require('fs');
const path = require('path');

// ── Event Types ─────────────────────────────────────────────────
const EVENT = {
  KILL: 'kill',
  DEATH: 'death',
  SUICIDE: 'suicide',
  JOIN: 'join',
  REJOIN: 'rejoin',
  DISCONNECT: 'disconnect',
  REACTOR_DESTROYED: 'reactor_destroyed',
  ESCAPE: 'escape',
  CHAT: 'chat',
  KILL_GOAL: 'kill_goal',
  SHIELD_WARNING: 'shield_warning',
  DAMAGE: 'damage',
  GAME_START: 'game_start',
  GAME_END: 'game_end',
  PROMOTION: 'promotion',
  DEMOTION: 'demotion',
  FLAG_CAPTURED: 'flag_captured',
  ORB_SCORED: 'orb_scored',
  UNKNOWN: 'unknown',
};

// ── Kill Patterns ───────────────────────────────────────────────
// DXX-Redux uses HUD_init_message with HM_KILLFEED flag for these.
// The actual text depends on who is the local player, but gamelog
// captures the text as-is from the host/observer perspective.

const KILL_PATTERNS = [
  // "KillerName killed VictimName!" - player kills player
  {
    regex: /^(.+?) killed (.+?)!$/,
    parse: (m) => ({ type: EVENT.KILL, killer: m[1], victim: m[2], method: 'weapon' }),
  },
  // "VictimName was killed by a mine!" - mine kill
  {
    regex: /^(.+?) was killed by a mine!$/,
    parse: (m) => ({ type: EVENT.DEATH, victim: m[1], cause: 'mine' }),
  },
  // "VictimName was killed by the reactor" / "killed by a non-player"
  {
    regex: /^(.+?) was killed by (?:the )?(?:reactor|a non-player|nonplay)\.?$/i,
    parse: (m) => ({ type: EVENT.DEATH, victim: m[1], cause: 'reactor' }),
  },
  // "VictimName was killed by a robot"
  {
    regex: /^(.+?) was killed by a robot\.?$/i,
    parse: (m) => ({ type: EVENT.DEATH, victim: m[1], cause: 'robot' }),
  },
  // "You were killed by a robot" (local player perspective)
  {
    regex: /^You were killed by a robot\.?$/i,
    parse: (m) => ({ type: EVENT.DEATH, victim: '_local_', cause: 'robot' }),
  },
  // "You were killed by a non-player" / reactor
  {
    regex: /^You were killed by (?:a )?(?:non-?player|nonplay)\.?$/i,
    parse: (m) => ({ type: EVENT.DEATH, victim: '_local_', cause: 'reactor' }),
  },
  // "You were killed by a mine!"
  {
    regex: /^You were killed by a mine!$/i,
    parse: (m) => ({ type: EVENT.DEATH, victim: '_local_', cause: 'mine' }),
  },
  // "VictimName killed VictimName!" - suicide (same name kills self)
  // Also: "PlayerName suicided"
  {
    regex: /^(.+?) suicided?\.?$/i,
    parse: (m) => ({ type: EVENT.SUICIDE, player: m[1] }),
  },
  // "You killed yourself!"
  {
    regex: /^You killed yourself!$/i,
    parse: (m) => ({ type: EVENT.SUICIDE, player: '_local_' }),
  },
];

// ── Game Event Patterns ─────────────────────────────────────────
const EVENT_PATTERNS = [
  // Player join/rejoin
  {
    regex: /^(?:\w+ )?'?(.+?)'? is (?:re)?joining the game\.?$/i,
    parse: (m) => ({ type: EVENT.JOIN, player: m[1] }),
  },
  {
    regex: /^(?:\w+ )?'?(.+?)'? is rejoining the game$/i,
    parse: (m) => ({ type: EVENT.REJOIN, player: m[1] }),
  },
  // Player disconnect / left
  {
    regex: /^(.+?) has left the game$/i,
    parse: (m) => ({ type: EVENT.DISCONNECT, player: m[1] }),
  },
  // Reactor/control center destroyed
  {
    regex: /^(.+?) has destroyed the control center!?$/i,
    parse: (m) => ({ type: EVENT.REACTOR_DESTROYED, player: m[1] }),
  },
  {
    regex: /^The control center has been destroyed!$/i,
    parse: () => ({ type: EVENT.REACTOR_DESTROYED, player: 'unknown' }),
  },
  {
    regex: /^You have destroyed the control center!?$/i,
    parse: () => ({ type: EVENT.REACTOR_DESTROYED, player: '_local_' }),
  },
  // Player escaped
  {
    regex: /^(.+?) has escaped!?$/i,
    parse: (m) => ({ type: EVENT.ESCAPE, player: m[1] }),
  },
  // Kill goal reached
  {
    regex: /^(.+?) has reached the kill goal!$/i,
    parse: (m) => ({ type: EVENT.KILL_GOAL, player: m[1] }),
  },
  {
    regex: /^You reached the kill goal!$/i,
    parse: () => ({ type: EVENT.KILL_GOAL, player: '_local_' }),
  },
  {
    regex: /^Kill goal reached by (.+?)!$/i,
    parse: (m) => ({ type: EVENT.KILL_GOAL, team: m[1] }),
  },
  {
    regex: /^The winner is (.+?), with the most kills!$/i,
    parse: (m) => ({ type: EVENT.KILL_GOAL, winner: m[1] }),
  },
  // Shield warnings (from observer damage tracking)
  {
    regex: /^Shield critical!$/i,
    parse: () => ({ type: EVENT.SHIELD_WARNING, level: 'critical' }),
  },
  {
    regex: /^Shields low\.$/i,
    parse: () => ({ type: EVENT.SHIELD_WARNING, level: 'low' }),
  },
  {
    regex: /^Shield warning\.$/i,
    parse: () => ({ type: EVENT.SHIELD_WARNING, level: 'warning' }),
  },
  // Promotions / Demotions
  {
    regex: /^You have been promoted to (.+?)!$/i,
    parse: (m) => ({ type: EVENT.PROMOTION, rank: m[1] }),
  },
  {
    regex: /^You have been demoted to (.+?)!$/i,
    parse: (m) => ({ type: EVENT.DEMOTION, rank: m[1] }),
  },
  // Hoard mode - play by play
  {
    regex: /^(?:Ouch|Haha)! (.+?) has been (?:smacked|spanked) by (.+?)!$/i,
    parse: (m) => ({ type: EVENT.KILL, victim: m[1], killer: m[2], method: 'hoard' }),
  },
  // Flag captured (CTF)
  {
    regex: /^(.+?) captured the (?:red|blue) flag!?$/i,
    parse: (m) => ({ type: EVENT.FLAG_CAPTURED, player: m[1] }),
  },
];

// ── Damage line patterns (from observer mode gamelog output) ────
// DXX-Redux writes damage lines like:
// "HH:MM:SS PlayerName took 15.3 from LaserName by AttackerName (shields: 84.7)"
const DAMAGE_PATTERN = /^(.+?) took ([\d.]+) from (.+?) by (.+?)(?: \(shields: ([\d.]+)\))?$/i;

// ── Parser ──────────────────────────────────────────────────────

/**
 * Parse a single gamelog.txt file into an array of structured events.
 * @param {string} filePath - Path to gamelog.txt or gamelog-*.txt
 * @param {object} options - { gameDate?: Date, localPlayer?: string }
 * @returns {Array} Array of event objects
 */
function parseGamelog(filePath, options = {}) {
  const content = fs.readFileSync(filePath, 'utf-8');
  return parseGamelogContent(content, options);
}

/**
 * Parse gamelog content string into structured events.
 * @param {string} content - Raw gamelog text content
 * @param {object} options - { gameDate?: Date, localPlayer?: string }
 * @returns {Array} Array of event objects
 */
function parseGamelogContent(content, options = {}) {
  const lines = content.split(/\r?\n/);
  const events = [];
  const gameDate = options.gameDate || new Date();
  const localPlayer = options.localPlayer || null;
  let lineNum = 0;

  for (const rawLine of lines) {
    lineNum++;
    const line = rawLine.trim();
    if (!line) continue;

    // Parse timestamp prefix: "HH:MM:SS message"
    const tsMatch = line.match(/^(\d{2}):(\d{2}):(\d{2})\s+(.*)$/);
    let timestamp = null;
    let message = line;

    if (tsMatch) {
      const [, hours, minutes, seconds, msg] = tsMatch;
      timestamp = new Date(gameDate);
      timestamp.setHours(parseInt(hours), parseInt(minutes), parseInt(seconds), 0);
      message = msg.trim();
    }

    if (!message) continue;

    // Strip color codes that DXX-Redux sometimes includes
    message = message.replace(/[\x01-\x1f]/g, '').trim();
    if (!message) continue;

    // Try kill patterns first (most frequent in multiplayer)
    let matched = false;
    for (const pattern of KILL_PATTERNS) {
      const m = message.match(pattern.regex);
      if (m) {
        const event = pattern.parse(m);
        event.timestamp = timestamp;
        event.rawMessage = message;
        event.line = lineNum;

        // Detect self-kills: "PlayerA killed PlayerA!" 
        if (event.type === EVENT.KILL && event.killer === event.victim) {
          event.type = EVENT.SUICIDE;
          event.player = event.killer;
          delete event.killer;
          delete event.victim;
        }

        events.push(event);
        matched = true;
        break;
      }
    }

    if (matched) continue;

    // Try game event patterns
    for (const pattern of EVENT_PATTERNS) {
      const m = message.match(pattern.regex);
      if (m) {
        const event = pattern.parse(m);
        event.timestamp = timestamp;
        event.rawMessage = message;
        event.line = lineNum;
        events.push(event);
        matched = true;
        break;
      }
    }

    if (matched) continue;

    // Try damage pattern (observer mode)
    const dmgMatch = message.match(DAMAGE_PATTERN);
    if (dmgMatch) {
      events.push({
        type: EVENT.DAMAGE,
        victim: dmgMatch[1],
        amount: parseFloat(dmgMatch[2]),
        weapon: dmgMatch[3],
        attacker: dmgMatch[4],
        shieldsRemaining: dmgMatch[5] ? parseFloat(dmgMatch[5]) : null,
        timestamp,
        rawMessage: message,
        line: lineNum,
      });
      continue;
    }

    // Check for chat messages (format: "PlayerName: message text")
    const chatMatch = message.match(/^(.{1,20}):\s+(.+)$/);
    if (chatMatch && !message.includes('killed') && !message.includes('destroyed')) {
      events.push({
        type: EVENT.CHAT,
        player: chatMatch[1].trim(),
        message: chatMatch[2].trim(),
        timestamp,
        rawMessage: message,
        line: lineNum,
      });
      continue;
    }

    // Unmatched lines are stored as unknown events (useful for debugging)
    events.push({
      type: EVENT.UNKNOWN,
      timestamp,
      rawMessage: message,
      line: lineNum,
    });
  }

  // ── Post-process: replace _local_ with actual player name ──
  if (localPlayer) {
    for (const event of events) {
      if (event.killer === '_local_') event.killer = localPlayer;
      if (event.victim === '_local_') event.victim = localPlayer;
      if (event.player === '_local_') event.player = localPlayer;
      if (event.attacker === '_local_') event.attacker = localPlayer;
      // Also fix rawMessage: replace "You" references with player name
      if (event.rawMessage) {
        event.rawMessage = event.rawMessage
          .replace(/^You killed yourself!$/i, `${localPlayer} killed ${localPlayer}!`)
          .replace(/^You were killed by (.+)$/i, `${localPlayer} was killed by $1`)
          .replace(/^You killed (.+?)!$/i, `${localPlayer} killed $1!`)
          .replace(/^You have destroyed the control center!?$/i, `${localPlayer} has destroyed the control center!`)
          .replace(/^You reached the kill goal!$/i, `${localPlayer} has reached the kill goal!`)
          .replace(/^You have been promoted to (.+?)!$/i, `${localPlayer} has been promoted to $1!`)
          .replace(/^You have been demoted to (.+?)!$/i, `${localPlayer} has been demoted to $1!`)
          .replace(/^You were damaged (.+)$/i, `${localPlayer} was damaged $1`);
      }
    }
  }

  return events;
}

/**
 * Replace all _local_ references in pre-parsed events with a player name.
 * Useful for multi-client gamelog merging: each client uploads their log,
 * and the server replaces _local_ with the uploading player's name.
 *
 * @param {Array} events - Parsed events (from parseGamelogContent)
 * @param {string} playerName - The player name to replace _local_ with
 * @returns {Array} Events with _local_ replaced
 */
function replaceLocalPlayer(events, playerName) {
  if (!playerName) return events;
  for (const event of events) {
    if (event.killer === '_local_') event.killer = playerName;
    if (event.victim === '_local_') event.victim = playerName;
    if (event.player === '_local_') event.player = playerName;
    if (event.attacker === '_local_') event.attacker = playerName;
    if (event.rawMessage) {
      event.rawMessage = event.rawMessage
        .replace(/^You killed yourself!$/i, `${playerName} killed ${playerName}!`)
        .replace(/^You were killed by (.+)$/i, `${playerName} was killed by $1`)
        .replace(/^You killed (.+?)!$/i, `${playerName} killed $1!`)
        .replace(/^You have destroyed the control center!?$/i, `${playerName} has destroyed the control center!`)
        .replace(/^You reached the kill goal!$/i, `${playerName} has reached the kill goal!`)
        .replace(/^You were damaged (.+)$/i, `${playerName} was damaged $1`);
    }
  }
  return events;
}

/**
 * Generate a game summary from parsed events.
 * @param {Array} events - Parsed events from parseGamelog
 * @returns {object} Summary with player stats, kill feed, damage breakdown
 */
function summarize(events) {
  const playerStats = {};
  const killFeed = [];
  const damageBreakdown = {};
  const timeline = [];
  const chatLog = [];

  // Helper to ensure a player entry exists
  function ensurePlayer(name) {
    if (!name || name === '_local_') return;
    if (!playerStats[name]) {
      playerStats[name] = {
        name,
        kills: 0,
        deaths: 0,
        suicides: 0,
        killStreak: 0,
        maxKillStreak: 0,
        currentStreak: 0,
        weapons: {},        // weapon -> kill count
        killedBy: {},       // who killed them -> count
        victims: {},        // who they killed -> count
        damageTaken: 0,
        damageDealt: 0,
        joinTime: null,
        leaveTime: null,
      };
    }
    return playerStats[name];
  }

  for (const event of events) {
    switch (event.type) {
      case EVENT.KILL: {
        const killer = ensurePlayer(event.killer);
        const victim = ensurePlayer(event.victim);

        if (killer) {
          killer.kills++;
          killer.currentStreak++;
          if (killer.currentStreak > killer.maxKillStreak) {
            killer.maxKillStreak = killer.currentStreak;
          }
          if (!killer.victims[event.victim]) killer.victims[event.victim] = 0;
          killer.victims[event.victim]++;
          if (event.method) {
            if (!killer.weapons[event.method]) killer.weapons[event.method] = 0;
            killer.weapons[event.method]++;
          }
        }

        if (victim) {
          victim.deaths++;
          victim.currentStreak = 0;
          if (!victim.killedBy[event.killer]) victim.killedBy[event.killer] = 0;
          victim.killedBy[event.killer]++;
        }

        killFeed.push({
          time: event.timestamp,
          killer: event.killer,
          victim: event.victim,
          method: event.method || 'unknown',
          message: event.rawMessage,
        });

        timeline.push({
          time: event.timestamp,
          type: 'kill',
          description: event.rawMessage,
        });
        break;
      }

      case EVENT.DEATH: {
        const victim = ensurePlayer(event.victim);
        if (victim) {
          victim.deaths++;
          victim.currentStreak = 0;
          if (!victim.killedBy[event.cause]) victim.killedBy[event.cause] = 0;
          victim.killedBy[event.cause]++;
        }

        killFeed.push({
          time: event.timestamp,
          victim: event.victim,
          cause: event.cause,
          message: event.rawMessage,
        });

        timeline.push({
          time: event.timestamp,
          type: 'death',
          description: event.rawMessage,
        });
        break;
      }

      case EVENT.SUICIDE: {
        const player = ensurePlayer(event.player);
        if (player) {
          player.suicides++;
          player.deaths++;
          player.currentStreak = 0;
        }

        killFeed.push({
          time: event.timestamp,
          player: event.player,
          type: 'suicide',
          message: event.rawMessage,
        });

        timeline.push({
          time: event.timestamp,
          type: 'suicide',
          description: event.rawMessage,
        });
        break;
      }

      case EVENT.DAMAGE: {
        const victim = ensurePlayer(event.victim);
        const attacker = ensurePlayer(event.attacker);

        if (victim) {
          victim.damageTaken += event.amount;
        }
        if (attacker) {
          attacker.damageDealt += event.amount;
        }

        // Track damage by weapon
        const key = `${event.attacker}|${event.weapon}`;
        if (!damageBreakdown[key]) {
          damageBreakdown[key] = {
            attacker: event.attacker,
            weapon: event.weapon,
            totalDamage: 0,
            hits: 0,
          };
        }
        damageBreakdown[key].totalDamage += event.amount;
        damageBreakdown[key].hits++;
        break;
      }

      case EVENT.JOIN:
      case EVENT.REJOIN: {
        ensurePlayer(event.player);
        if (playerStats[event.player]) {
          playerStats[event.player].joinTime = event.timestamp;
        }
        timeline.push({
          time: event.timestamp,
          type: 'join',
          description: event.rawMessage,
        });
        break;
      }

      case EVENT.DISCONNECT: {
        if (playerStats[event.player]) {
          playerStats[event.player].leaveTime = event.timestamp;
        }
        timeline.push({
          time: event.timestamp,
          type: 'disconnect',
          description: event.rawMessage,
        });
        break;
      }

      case EVENT.REACTOR_DESTROYED: {
        timeline.push({
          time: event.timestamp,
          type: 'reactor',
          description: event.rawMessage,
          player: event.player,
        });
        break;
      }

      case EVENT.ESCAPE: {
        timeline.push({
          time: event.timestamp,
          type: 'escape',
          description: event.rawMessage,
          player: event.player,
        });
        break;
      }

      case EVENT.CHAT: {
        chatLog.push({
          time: event.timestamp,
          player: event.player,
          message: event.message,
        });
        break;
      }

      case EVENT.KILL_GOAL: {
        timeline.push({
          time: event.timestamp,
          type: 'kill_goal',
          description: event.rawMessage,
        });
        break;
      }

      default:
        break;
    }
  }

  // Compute kill matrix
  const playerNames = Object.keys(playerStats);
  const killMatrix = {};
  for (const name of playerNames) {
    killMatrix[name] = {};
    for (const otherName of playerNames) {
      killMatrix[name][otherName] = playerStats[name].victims[otherName] || 0;
    }
  }

  // Sort damage breakdown by total damage
  const sortedDamage = Object.values(damageBreakdown)
    .sort((a, b) => b.totalDamage - a.totalDamage);

  return {
    players: Object.values(playerStats).map((p) => ({
      ...p,
      weapons: p.weapons,
      killedBy: p.killedBy,
      victims: p.victims,
    })),
    killFeed,
    killMatrix,
    damageBreakdown: sortedDamage,
    timeline,
    chatLog,
    totalEvents: events.length,
    totalKills: killFeed.filter((k) => k.killer).length,
    totalDeaths: killFeed.length,
    duration: events.length > 1
      ? { start: events[0].timestamp, end: events[events.length - 1].timestamp }
      : null,
  };
}

/**
 * Find all gamelog files in a directory.
 * @param {string} dir - Directory to scan
 * @returns {Array} Array of { path, filename, timestamp }
 */
function findGamelogs(dir) {
  if (!fs.existsSync(dir)) return [];

  const files = fs.readdirSync(dir);
  return files
    .filter((f) => f.match(/^gamelog.*\.txt$/i))
    .map((f) => {
      const fullPath = path.join(dir, f);
      const stat = fs.statSync(fullPath);

      // Try to extract timestamp from filename: gamelog-YYYYMMDD-HHMMSS.txt
      // or gamelog-mission-level-YYYYMMDD-HHMMSS.txt
      let fileDate = stat.mtime;
      const tsMatch = f.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})\.txt$/);
      if (tsMatch) {
        fileDate = new Date(
          parseInt(tsMatch[1]), parseInt(tsMatch[2]) - 1, parseInt(tsMatch[3]),
          parseInt(tsMatch[4]), parseInt(tsMatch[5]), parseInt(tsMatch[6])
        );
      }

      return {
        path: fullPath,
        filename: f,
        timestamp: fileDate,
        size: stat.size,
      };
    })
    .sort((a, b) => b.timestamp - a.timestamp);
}

module.exports = {
  EVENT,
  parseGamelog,
  parseGamelogContent,
  replaceLocalPlayer,
  summarize,
  findGamelogs,
};
